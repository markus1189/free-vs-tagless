\documentclass[aspectratio=169, hyperref={colorlinks, linkcolor=beamer@centricgreen}, urlcolor=links]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\usepackage[listings, minted]{tcolorbox}
\usepackage{smartdiagram}
\usepackage[export]{adjustbox}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=orange!50, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free vs Final Tagless}
\author{Markus Hauck (@markus1189)}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
  \begin{center}
    {\Huge Free vs Tagless}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Content}
  \begin{itemize}
  \item start with the basics from Oleg's excellent paper
  \item \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \item clarify tagged, tagless, initial and final
  \item relation to Free-X constructions
  \item comparison of both approaches
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Toy Language}
  \begin{itemize}
  \item toy language with operations
  \item integer constants
  \item integer addition
  \item string constants
  \item string concatenation
  \end{itemize}
\end{frame}

\section{Initial vs Final vs Tagged}\label{sec:initial-final-tagged}

\begin{frame}
  \frametitle{Terminology}

  directly from the \href{http://okmij.org/ftp/tagless-final/course/lecture.pdf}{paper}:
  \vfill
  \begin{quote}
    There are \textbf{two basic approaches} to embedding languages and
    writing their interpreters, which we shall call, somewhat
    informally, \textbf{initial} and \textbf{final}.
  \end{quote}
  \vfill
  \begin{quote}
    The \textbf{initial} approach represents a term of an object
    language \textbf{as a value} of an algebraic data type in the
    metalanguage; interpreters recursively traverse the values
    de-constructing them by \textbf{pattern-matching}.
  \end{quote}
  \vfill
  \begin{quote}
    In the \textbf{final} approach, object language terms are
    represented as expressions built from a small set of
    \textbf{combinators}, which are \textbf{ordinary functions} rather
    than data constructors.
  \end{quote}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item small language: addition, concatenation, literals and conversion
  \end{itemize}
  \begin{minted}{scala}
    1 + 1
    "hello," + " world"
    "42".toInt
  \end{minted}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-expr.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-sample.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-interp.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-add.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item problems: have to handle errors in interpreter
  \item should: don't allow invalid programs at all
  \item btw: this is a very nice criteria for \texttt{any} DSL
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagged Initial Encoding}
  \begin{itemize}
  \item initial encoding =
  \item ``tagged union'' a.k.a.\ sum types in type theory
  \item this ``tag'' is used for pattern matching
  \item programs are first class, store as data etc
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagless Initial Encoding}
  \begin{itemize}
  \item get rid of invalid programs using GADTs
  \item caveat: type inference in Scala\ldots{}
  \item introduce smart constructors
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-expr.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-sample.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-interp.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-add.scala}
\end{frame}

\begin{frame}
  \frametitle{Tagless Final Encoding}
  \begin{itemize}
  \item use typeclasses and functions
  \item interpreter are defined as an instance of the typeclass
  \item type safety built in
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-expr.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-sample.scala}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-interp.scala}
\end{frame}

\section{Free And Final Tagless}\label{sec:free-and-final-tagless}

\begin{frame}
  \begin{itemize}
  \item also: tagged initial encoding
  \item ``tagged'' because sum types are represented at runtime as
    pairs (tag, payload), the tag is used in ``eval'' to do pattern
    matching
  \item use data structure to capture the program
  \item traverse this structure using interpreter
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagged Initial Encoding}
  \begin{itemize}
  \item Free is an tagged initial encoding
  \item but a Free X is normally associated to a typeclass + laws
  \item Free Monad, Free Applicative, Free Monoid
  \item tagged initial encoding of a typeclass
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tags}
  \begin{itemize}
  \item untyped representation that allows invalid constants
  \item GADT makes wrong expression not representable
  \item tagged and tagless initial encoding possible
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free \textemdash{} Pros and Cons}
  \begin{itemize}
  \item program reified as a data structure
  \item allows inspection and transformation
  \item can be serialized
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item use overloaded functions (all the way)
  \item use denotation in semantic algebra and not AST
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Problem}
  \begin{itemize}
  \item extremely nice property of finally tagless
  \item extensibility in two dimensions
  \item neat way to solve expression problem!
  \end{itemize}
\end{frame}

\section{Optimization And Inspection}\label{sec:optimization-and-inspection}

\begin{frame}
  \frametitle{Optimization}
  \begin{itemize}
  \item time to talk about program optimization and transformation
  \item start with Free, then finally tagless
  \item myth: not possible in finally tagless, which is wrong
  \item instantiate interpreter that keeps track of information that is passed down
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Analyzing Programs}
  \begin{itemize}
  \item in both approaches: level of introspection depends
  \item if you use Monad, very limited
  \item the more you represent, the more power
  \end{itemize}
\end{frame}

\section{Comparison}\label{sec:free-vs-tagless}

\begin{frame}
  \frametitle{Free vs Finally Tagless}
  \begin{itemize}
  \item seen both approaches
  \item but important question: when to use which
  \item spoiler: it depends
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Free}
  \begin{itemize}
  \item doing a lot of transformation/optimization
  \item ability to serialize/deserialize program
  \item doing partial evaluation
  \item pass around programs in data structures
  \item type safety via ``tagless'' representation often requires GADT
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Finally Tagless}
  \begin{itemize}
  \item programs are inspected max once
  \item executed a lot more than inspected
  \item no need to keep around the data structure at all
  \item nicely solves the expression problem (no small feat)
  \item trivial to compose different languages
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Both}
  \begin{itemize}
  \item saw: reason for either one
  \item can we have our cake and eat it, too?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Converting from Free to Finally Tagless}
\end{frame}

\begin{frame}
  \frametitle{Converting from Finally Tagless to Free}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
  \item flexible and \texttt{composable} way to cacluate metrics over text
  \item using \texttt{Monoid} and \texttt{Applicative}
  \item works with iteration and streaming
  \item Principle Of Least Power: sometimes Monads are overrated
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The End}
  \begin{itemize}
  \item \hyperref[sec:introduction]{Introduction}
  \item \hyperref[sec:monoids]{Monoids}
  \item \hyperref[sec:applicatives]{Applicatives}
  \item \hyperref[sec:streaming]{Streaming}
  \item \hyperref[sec:conclusion]{Conclusion}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}
  \frametitle{References}
  \begin{center}
    \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \end{center}
\end{frame}

\appendix{}

\end{document}
