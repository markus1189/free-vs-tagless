\documentclass[aspectratio=169, hyperref={colorlinks, linkcolor=beamer@centricgreen}, urlcolor=links]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\usepackage[listings, minted]{tcolorbox}
\usepackage{smartdiagram}
\usepackage[export]{adjustbox}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=orange!50, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free vs Final Tagless}
\author{Markus Hauck (@markus1189)}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
  \begin{center}
    {\Huge Free vs Tagless}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Content}
  \begin{itemize}
  \item start with the basics from Oleg's excellent paper
  \item \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \item clarify tagged, tagless, initial and final
  \item relation to Free-X constructions
  \item comparison of both approaches
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Toy Language}
  \begin{itemize}
  \item toy language with operations
  \item integer constants
  \item integer addition
  \item string constants
  \item string concatenation
  \end{itemize}
\end{frame}

\section{Initial vs Final vs Tagged}\label{sec:initial-final-tagged}

\begin{frame}
  \begin{center}
    \Huge
    Initial vs Final vs Tagged
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Terminology}

  directly from the \href{http://okmij.org/ftp/tagless-final/course/lecture.pdf}{paper}:
  \vfill
  \begin{quote}
    There are \textbf{two basic approaches} to embedding languages and
    writing their interpreters, which we shall call, somewhat
    informally, \textbf{initial} and \textbf{final}.
  \end{quote}
  \vfill
  \begin{quote}
    The \textbf{initial} approach represents a term of an object
    language \textbf{as a value} of an algebraic data type in the
    metalanguage; interpreters recursively traverse the values
    de-constructing them by \textbf{pattern-matching}.
  \end{quote}
  \vfill
  \begin{quote}
    In the \textbf{final} approach, object language terms are
    represented as expressions built from a small set of
    \textbf{combinators}, which are \textbf{ordinary functions} rather
    than data constructors.
  \end{quote}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item small language: addition, concatenation, literals and conversion
  \end{itemize}
  \begin{minted}{scala}
    1 + 1
    "hello," + " world"
    "42".toInt
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-interp.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-add.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item problems: have to handle errors in interpreter
  \item should: don't allow invalid programs at all
  \item btw: this is a very nice criteria for \texttt{any} DSL
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagged Initial Encoding}
  \begin{itemize}
  \item initial encoding =
  \item ``tagged union'' a.k.a.\ sum types in type theory
  \item this ``tag'' is used for pattern matching
  \item programs are first class, store as data etc
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagless Initial Encoding}
  \begin{itemize}
  \item get rid of invalid programs using GADTs
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-interp.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-add.scala}
\end{frame}

\begin{frame}
  \frametitle{Tagless Final Encoding}
  \begin{itemize}
  \item use typeclasses and functions
  \item interpreter are defined as an instance of the typeclass
  \item type safety built in
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-interp.scala}
\end{frame}

\begin{frame}
  \frametitle{First Summary}
  \begin{itemize}
  \item we saw: initial tagged, initial tagless and final tagless
  \item implemented simple language
  \item next: compose languages
  \end{itemize}
\end{frame}

\section{Case Study: Adding If}\label{sec:case-study-if}

\begin{frame}
  \frametitle{The Expression Problem}
  \begin{tcolorbox}[
    fonttitle=\sffamily\bfseries,
    colbacktitle=black,
    colframe=black,
    coltitle=beamer@centricgreen,
    title=Philip Wadler on 12. November 1998
    ]
    The Expression Problem is a new name for an old problem.  The goal
    is to define a datatype by cases, where one can add new cases to
    the datatype and new functions over the datatype, without
    recompiling existing code, and while retaining static type safety
    (e.g., no casts).
  \end{tcolorbox}
  \begin{itemize}
  \item there are other solutions, but the final encoding is
    pretty neat (IMHO)
  \item the initial encoding equivalent is ``Data types a la carte''
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{center}
    \Huge
    Case Study: Adding ``if''
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Case Study: Adding ``if''}
  \begin{itemize}
  \item the goal is to add the ``if'' to our language
  \item do it for
    \begin{itemize}
    \item initial tagless
    \item final tagless
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-expr-if.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-sample-if.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-interp-if.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-handle-if.scala}
\end{frame}

\begin{frame}
  \frametitle{Case Study: If with Initial Tagless}
  \begin{itemize}
  \item this is what the expression problem is all about
  \item had to touch the language and \textbf{all} interpreters
  \item problem: what if we regularly extend the language?
  \item better: if we could compose languages instead of changing
  \item initial solution: datatypes a la carte
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Datatypes a la carte}
  \begin{itemize}
  \item TODO: link to paper
  \item demonstrating the use of fixed point and parameterized expressions over a type constructor
  \item use a typeclass to inject languages into a coproduct
  \item in cats: \textbf{InjectK} and \texttt{Inject}
  \item but in summary: big pain, you probably don't want to go there
  \item instead: let's look at final tagless version
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-expr-if.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-sample-if.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Case Study: If with Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-interp-if.scala}
\end{frame}

\begin{frame}
  \frametitle{Case Study: If with Final Tagless}
  \begin{itemize}
  \item no need to touch \texttt{Interp} class, just add an instance
  \item we are able to re-use the \textbf{ExprSym} in programs
  \item this solves the expression problem, we did not have to change existing things
  \item and without all the hassle of \texttt{Inject} and datatypes a la carte
  \item this is the big advantage of the final tagless encoding
  \end{itemize}
\end{frame}

\section{Working With Programs}\label{sec:working-with-programs}

\begin{frame}
  \begin{center}
    \Huge
    Working With Programs
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Optimization}
  \begin{itemize}
  \item time to talk about program optimization and transformation
  \item DSL:\@ program is written once, interpreted many times
  \item myth: inspection/transformation impossible in finally tagless
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Optimization: Inlining of Addition}
  \begin{itemize}
  \item goal: inline addition with literals
  \item i.e.\@ all \texttt{Add} with only \texttt{IntLit} children
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Optimization: Inlining of Addition}
  {
    \tikzstyle{level 1}=[sibling distance=10em]
    \tikzstyle{level 2}=[sibling distance=6em]
%
    \begin{columns}
      \begin{column}{0.5\textwidth}
        \begin{center}
          \begin{tikzpicture}[every node/.style = {shape=rectangle, rounded corners, draw, align=center}]]
            \node {Add}
            child { node[fill=beamer@centricgreen] {Add}
              child { node[fill=beamer@centricgreen] {IntLit(21) } }
              child { node[fill=beamer@centricgreen] {IntLit(21) } }
            }
            child { node {StrToInt}
              child { node {StrLit("0") } }
            };
          \end{tikzpicture}
        \end{center}
      \end{column}
      \begin{column}{0.5\textwidth}
        \begin{center}
          \begin{tikzpicture}[every node/.style = {shape=rectangle, rounded corners, draw, align=center}]]
            \node {Add}
            child { node[fill=beamer@centricgreen] {IntLit(42)} }
            child { node {StrToInt}
              child { node {StrLit("0") } }
            };
          \end{tikzpicture}
        \end{center}
      \end{column}
    \end{columns}
  }
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initial Encoding: Inlining of Addition}
  \begin{itemize}
  \item initial encoding: we are building the tree and use pattern matching
  \item the program tree looks like this in the DSL
  \end{itemize}
  \vspace{5mm}
  \begin{minted}{scala}
    Add(Add(IntLit(21), IntLit(21)), StrToInt(StrLit("0")))
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initial Encoding: Inlining of Addition}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/optimizer-inline-addition.scala}
\end{frame}

\begin{frame}
  \frametitle{Final Encoding: Inlining of Addition}
  \begin{itemize}
  \item with the final encoding there is no program
  \item no pattern matching on the AST
  \item trick: explicate the necessary context using a special instance
  \item keep track of predecessors during traversal
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initial Encoding: Inlining of Addition}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-opt-ctx.scala}
  \vfill{}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-opt-type.scala}
  \vfill{}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-opt-sig.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Initial Encoding: Inlining of Addition}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-opt-impl.scala}
\end{frame}

\begin{frame}[fragile]
  \begin{itemize}
  \item<1-> making the context explicit is non-mechanic
  \item<1-> you lose the pattern matching language from initial
  \item<1-> in a nutshell, this is the big trade-off
  \item<1-> still, you can do every optimization in final \textbf{and} initial
  \item<1-> some things are just really hard (like de-/serialization)
  \item<2> State Monad anyone?
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Final vs Initial: Final2Initial}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-to-initial.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Final vs Initial: Initial2Final}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-to-final.scala}
\end{frame}

\section{Free And MTL}\label{sec:free-and-mtl}

\begin{frame}
  \begin{center}
    \Huge
    Free And MTL
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Free As Initial Encoding}
  \begin{itemize}
  \item Free is an initial encoding
  \item but a Free X is associated to a \textbf{typeclass} + laws
  \item the minimal \textbf{initially encoded} structure satisfying
    the laws
  \item Free Monad, Free Applicative, Free Monoid
  \item initial encoding + DSL based on typeclass
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Free Monad}
  TOOD: code
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Free Monad}
  \begin{itemize}
  \item we use Monad to embed our language
  \item extract the real value at every step
  \item nice: interop with standard Scala
  \item nice: lots of combinators for monads exist already
  \item bad: interpreter fixes sequential evaluation
  \item but just an example, could've used \texttt{FreeApplicative}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{MTL as Final Encoding}
  \begin{itemize}
  \item basic idea: define type class for ``additional'' operations of a special Monad
  \item e.g.\ accessing state, reading environment, etc.
  \item implemented in the \texttt{mtl} package in Haskell
  \item commonly referred to as ``mtl-style''
  \item final encoding that uses the special ops as DSL!\@
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free \textemdash{} Pros and Cons}
  \begin{itemize}
  \item program reified as a data structure
  \item allows inspection and transformation
  \item can be serialized
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Analyzing Programs}
  \begin{itemize}
  \item in both approaches: level of introspection depends
  \item if you use Monad, very limited
  \item the more you represent, the more power
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item use overloaded functions (all the way)
  \item use denotation in semantic algebra and not AST
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Problem}
  \begin{itemize}
  \item extremely nice property of finally tagless
  \item extensibility in two dimensions
  \item neat way to solve expression problem!
  \end{itemize}
\end{frame}

\section{Comparison}\label{sec:comparison}

\begin{frame}
  \begin{center}
    \Huge
    Comparison
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Free vs Finally Tagless}
  \begin{itemize}
  \item seen both approaches
  \item but important question: when to use which
  \item spoiler: it depends
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Free}
  \begin{itemize}
  \item doing a lot of transformation/optimization
  \item ability to serialize/deserialize program
  \item doing partial evaluation
  \item pass around programs in data structures
  \item type safety via ``tagless'' representation often requires GADT
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Finally Tagless}
  \begin{itemize}
  \item programs are inspected max once
  \item executed a lot more than inspected
  \item no need to keep around the data structure at all
  \item nicely solves the expression problem (no small feat)
  \item trivial to compose different languages
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Both}
  \begin{itemize}
  \item saw: reason for either one
  \item can we have our cake and eat it, too?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Converting from Free to Finally Tagless}
\end{frame}

\begin{frame}
  \frametitle{Converting from Finally Tagless to Free}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
  \item flexible and \texttt{composable} way to cacluate metrics over text
  \item using \texttt{Monoid} and \texttt{Applicative}
  \item works with iteration and streaming
  \item Principle Of Least Power: sometimes Monads are overrated
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The End}
  \begin{itemize}
  \item \hyperref[sec:introduction]{Introduction}
  \item \hyperref[sec:monoids]{Monoids}
  \item \hyperref[sec:applicatives]{Applicatives}
  \item \hyperref[sec:streaming]{Streaming}
  \item \hyperref[sec:conclusion]{Conclusion}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}
  \frametitle{References}
  \begin{center}
    \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \end{center}
\end{frame}

\appendix{}

\end{document}
