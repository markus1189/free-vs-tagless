\documentclass[aspectratio=169, hyperref={colorlinks, linkcolor=beamer@centricgreen}, urlcolor=links]{beamer}

% Must be loaded first
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,calc}

\usepackage[utf8]{inputenc}
\usepackage{textpos}

% Font configuration
\usepackage{fontspec}

\usepackage[listings, minted]{tcolorbox}
\usepackage{smartdiagram}
\usepackage[export]{adjustbox}

\input{font.tex}

% Tikz for beautiful drawings
\usetikzlibrary{mindmap,backgrounds}
\usetikzlibrary{arrows.meta,arrows}
\usetikzlibrary{shapes.geometric}

% Minted configuration for source code highlighting
\usepackage{minted}
\setminted{highlightcolor=orange!50, linenos}
\setminted{style=lovelace}

\usepackage[listings, minted]{tcolorbox}
\tcbset{left=6mm}

% Use the include theme
\usetheme{codecentric}

% Metadata
\title{Free vs Final Tagless}
\author{Markus Hauck (@markus1189)}

% The presentation content
\begin{document}

\begin{frame}[noframenumbering,plain]
  \titlepage{}
\end{frame}

\section{Introduction}\label{sec:introduction}

\begin{frame}
  \begin{center}
    {\Huge Free vs Tagless}
  \end{center}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Content}
  \begin{itemize}
  \item start with the basics from Oleg's excellent paper
  \item \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \item clarify tagged, tagless, initial and final
  \item relation to Free-X constructions
  \item comparison of both approaches
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Toy Language}
  \begin{itemize}
  \item toy language with operations
  \item integer constants
  \item integer addition
  \item string constants
  \item string concatenation
  \end{itemize}
\end{frame}

\section{Initial vs Final vs Tagged}\label{sec:initial-final-tagged}

\begin{frame}
  \begin{center}
    \Huge
    Initial vs Final vs Tagged
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Terminology}

  directly from the \href{http://okmij.org/ftp/tagless-final/course/lecture.pdf}{paper}:
  \vfill
  \begin{quote}
    There are \textbf{two basic approaches} to embedding languages and
    writing their interpreters, which we shall call, somewhat
    informally, \textbf{initial} and \textbf{final}.
  \end{quote}
  \vfill
  \begin{quote}
    The \textbf{initial} approach represents a term of an object
    language \textbf{as a value} of an algebraic data type in the
    metalanguage; interpreters recursively traverse the values
    de-constructing them by \textbf{pattern-matching}.
  \end{quote}
  \vfill
  \begin{quote}
    In the \textbf{final} approach, object language terms are
    represented as expressions built from a small set of
    \textbf{combinators}, which are \textbf{ordinary functions} rather
    than data constructors.
  \end{quote}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item small language: addition, concatenation, literals and conversion
  \end{itemize}
  \begin{minted}{scala}
    1 + 1
    "hello," + " world"
    "42".toInt
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-interp.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagged-add.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagged}
  \begin{itemize}
  \item problems: have to handle errors in interpreter
  \item should: don't allow invalid programs at all
  \item btw: this is a very nice criteria for \texttt{any} DSL
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagged Initial Encoding}
  \begin{itemize}
  \item initial encoding =
  \item ``tagged union'' a.k.a.\ sum types in type theory
  \item this ``tag'' is used for pattern matching
  \item programs are first class, store as data etc
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Tagless Initial Encoding}
  \begin{itemize}
  \item get rid of invalid programs using GADTs
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-interp.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Initial Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/initial-tagless-add.scala}
\end{frame}

\begin{frame}
  \frametitle{Tagless Final Encoding}
  \begin{itemize}
  \item use typeclasses and functions
  \item interpreter are defined as an instance of the typeclass
  \item type safety built in
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-expr.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-sample.scala}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Interpreter: Final Tagless}
  \inputminted[fontsize=\footnotesize]{scala}{snippets/final-tagless-interp.scala}
\end{frame}

\begin{frame}
  \frametitle{First Summary}
  \begin{itemize}
  \item we saw: initial tagged, initial tagless and final tagless
  \item implemented simple language
  \item next: compose languages
  \end{itemize}
\end{frame}

\section{Composition Of Languages}\label{sec:composition-languages}

\begin{frame}
  \begin{center}
    \Huge
    Composition Of Languages
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{The Expression Problem}
  \begin{tcolorbox}[
    fonttitle=\sffamily\bfseries,
    colbacktitle=black,
    colframe=black,
    coltitle=beamer@centricgreen,
    title=Philip Wadler on 12. November 1998
    ]
    The Expression Problem is a new name for an old problem.  The goal
    is to define a datatype by cases, where one can add new cases to
    the datatype and new functions over the datatype, without
    recompiling existing code, and while retaining static type safety
    (e.g., no casts).
  \end{tcolorbox}
  \begin{itemize}
  \item there are other solutions, but the final encoding is
    pretty neat (IMHO)
  \item the initial encoding equivalent is ``Data types a la carte''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The Expression Problem}
  TODO: show example for final? also for initial? or only mention it?
\end{frame}

\section{Free And Final Tagless}\label{sec:free-and-final-tagless}

\begin{frame}
  \begin{center}
    \Huge
    Free And Final Tagless
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Free As Initial Encoding}
  \begin{itemize}
  \item Free is an tagged initial encoding
  \item but a Free X is associated to a \textbf{typeclass} + laws
  \item the minimal \textbf{initially encoded} structure satisfying
    the laws
  \item Free Monad, Free Applicative, Free Monoid
  \item initial encoding + DSL based on typeclass
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Free Monad}
  TOOD: code
\end{frame}

\begin{frame}
  \frametitle{Interpreter: Free Monad}
  \begin{itemize}
  \item we use Monad to embed our language
  \item extract the real value at every step
  \item nice: interop with standard Scala
  \item bad: interpreter fixes sequential evaluation
  \item but just an example, could've used \texttt{FreeApplicative}
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{MTL as Final Encoding}
  \begin{itemize}
  \item basic idea: define type class for ``additional'' operations of a special Monad
  \item e.g.\ accessing state, reading environment, etc.
  \item implemented in the \texttt{mtl} package in Haskell
  \item commonly referred to as ``mtl-style''
  \item final encoding that uses the special ops as DSL!\@
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Free \textemdash{} Pros and Cons}
  \begin{itemize}
  \item program reified as a data structure
  \item allows inspection and transformation
  \item can be serialized
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
  \item use overloaded functions (all the way)
  \item use denotation in semantic algebra and not AST
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Expression Problem}
  \begin{itemize}
  \item extremely nice property of finally tagless
  \item extensibility in two dimensions
  \item neat way to solve expression problem!
  \end{itemize}
\end{frame}

\section{Working With Programs}\label{sec:working-with-programs}

\begin{frame}
  \begin{center}
    \Huge
    Working With Programs
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Optimization}
  \begin{itemize}
  \item time to talk about program optimization and transformation
  \item start with Free, then MTL
  \item myth: not possible in finally tagless, which is wrong
  \item instantiate interpreter that keeps track of information that is passed down
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Analyzing Programs}
  \begin{itemize}
  \item in both approaches: level of introspection depends
  \item if you use Monad, very limited
  \item the more you represent, the more power
  \end{itemize}
\end{frame}

\section{Comparison}\label{sec:comparison}

\begin{frame}
  \begin{center}
    \Huge
    Comparison
  \end{center}
\end{frame}

\begin{frame}
  \frametitle{Free vs Finally Tagless}
  \begin{itemize}
  \item seen both approaches
  \item but important question: when to use which
  \item spoiler: it depends
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Free}
  \begin{itemize}
  \item doing a lot of transformation/optimization
  \item ability to serialize/deserialize program
  \item doing partial evaluation
  \item pass around programs in data structures
  \item type safety via ``tagless'' representation often requires GADT
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Finally Tagless}
  \begin{itemize}
  \item programs are inspected max once
  \item executed a lot more than inspected
  \item no need to keep around the data structure at all
  \item nicely solves the expression problem (no small feat)
  \item trivial to compose different languages
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{When To Use Both}
  \begin{itemize}
  \item saw: reason for either one
  \item can we have our cake and eat it, too?
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Converting from Free to Finally Tagless}
\end{frame}

\begin{frame}
  \frametitle{Converting from Finally Tagless to Free}
\end{frame}

\section{Conclusion}\label{sec:conclusion}

\begin{frame}
  \frametitle{Conclusion}
  \begin{itemize}
  \item flexible and \texttt{composable} way to cacluate metrics over text
  \item using \texttt{Monoid} and \texttt{Applicative}
  \item works with iteration and streaming
  \item Principle Of Least Power: sometimes Monads are overrated
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{The End}
  \begin{itemize}
  \item \hyperref[sec:introduction]{Introduction}
  \item \hyperref[sec:monoids]{Monoids}
  \item \hyperref[sec:applicatives]{Applicatives}
  \item \hyperref[sec:streaming]{Streaming}
  \item \hyperref[sec:conclusion]{Conclusion}
  \end{itemize}
  \vfill
\end{frame}

\begin{frame}
  \frametitle{References}
  \begin{center}
    \href{http://okmij.org/ftp/tagless-final/course/index.html}{Typed tagless-final interpretations: Lecture notes}
  \end{center}
\end{frame}

\appendix{}

\end{document}
